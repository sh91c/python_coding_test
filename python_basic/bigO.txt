1. O(1)
- 데이터의 크기에 상관없이 처리 시간은 일정하다.
- 해시 테이블의 조회 및 삽입이 이에 해당.

2. O(logN)
- 데이터의 크기에 따라 처리 시간에 영향이 있지만, logN은 데이터의 크기가 크더라도
  크게 영향을 받지 않는 편으로 웬만한 n의 크기에 대해 견고하다.
- 이진 검색이 이에 해당.

3. O(n)
- 데이터의 크기에 따라 처리 시간이 늘어남.
- 알고리즘을 수행하는 데 걸리는 시간은 데이터의 크기에 비례한다.
- 이러한 알고리즘을 선형 시간 알고리즘이라고 한다.
- 정렬되지 않은 리스트에서 최댓값 또는 최솟값을 찾는 경우가 이에 해당하며
  이 값을 찾기 위해 모든 데이터를 최소 한 번 이상은 살펴봐야한다.

4. O(nLogN)
- 병합 정렬을 지롤한 대부분의 효율이 좋은 정렬 알고리즘이 이에 해당함.
- 입력값이 최선인 경우, 비교를 건너뛰어 O(n)이 될 수 있으며 팀소트(Timsort)가 이런 로직을 가짐.

5. O(n^2)
- 버블 정렬같은 비효율적 정렬 알고리즘이 이에 해당함.

6. O(2n)
- 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당함.
- n^2보다 2n이 훨씬 처리 시간이 길다.

7. O(n!)
- 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 문제를 브루트 포스로 풀이할 때 해당.
- 가장 느린 알고리즘으로 데이터의 크기가 조금만 커져도 계산이 어려움.
